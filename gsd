#!/bin/bash
############################################################################
#
#  GSD (gsd) is a utility to show, modify, and manage to-do lists.
#
#  Copyright (C) 2011-2012  Jason Graham <jgraha8@gmail.com>
#  Copyright (C) 2017-2018  Jason Graham <jgraham@compukix.net>
#
#  This file is part of gsd
#
#  gsd is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  gsd is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with gsd.  If not, see <http://www.gnu.org/licenses/>.
#
############################################################################

SCRIPTNAME=`basename "$0"`
GSDDIR="$HOME/.gsd"
GSDLIST="default"
GSDVERSION="1.0"

# Attribute codes:
# 00=none 01=bold 04=underscore 05=blink 07=reverse 08=concealed

# Text color codes:
# 30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white

# Background color codes:
# 40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white

# COLOR="<attribute>;<text>;<background>"

BLACK="01;30"
RED="01;31"
GREEN="01;32"
YELLOW="01;33"
BLUE='01;34'
MAGENTA="01;35"
CYAN="01;36"

COLOR_FLAG="\033[${RED}m"
COLOR_LIST="\033[${BLUE}m"
COLOR_END="\033[0m"

# OS check
OSNAME=`uname`

# OS specific work arounds
if [[ "$OSNAME" == 'Darwin' || "$OSNAME" == 'FreeBSD' ]]; then
    SED_WRITE_LINE="sed_write_line_bsd"
else
    SED_WRITE_LINE="sed_write_line"
fi


#####################################################################
# STDOUT PRINT FUNCTIONS
#####################################################################

#---------------------------------------------------------------------
# SHOW_USAGE_MESSAGE
#---------------------------------------------------------------------

function show_usage_message {
    echo "Usage: $SCRIPTNAME [options] <command> [args]"
    echo ""
    echo "Options:"
    echo "  -c <file>                   Specify which gsd config file to use (default: \$HOME/.gsd/config)"        
    echo "  -d <dir>                    Specify which gsd directory to use (default: \$HOME/.gsd)"    
    echo "  -l <list>                   Specify which list to use (default: default)"
    echo " "
    echo "Commands:"
    echo "  h, help                     Print this message"
    echo "  i, info                     Show basic usage"
    echo "  s, show                     Show entries in list"
    echo "    Options:"
    echo "      -n                      Show only entries with status new"
    echo "      -i                      Show only entries with status incomplete"
    echo "      -c                      Show only entries with status complete"
    echo "      -f                      Show only flagged entries"
    echo "  a, add <statement>          Add new entry"
    echo "  im, import <file>           Import a file of new entries (one entry per line)"
    echo "  d, delete <tag>             Delete entry"
    echo "  st, status {N|I|C} <tag>    Change status of entry (status setting is case insensitive)"
    echo "  f, flag <tag-spec>          Toggle important flag (ex. tag-spec: 2-5,7,9-10)"
    echo "  e, edit                     Edit entry in list"
    echo "    Options:"
    echo "      -m                      Change entry statement"
    echo "      -r                      Reorder entry tags"
    echo "  se, search <phrase>         Perform text search on entries"
    echo "  b, bump <tag a> <tag b>     Move entry at tag a to tag b"
    echo "  p, purge                    Remove all completed entries"
    echo "  pr, print                   Send list entries to printer"
    echo "    Options:"
    echo "      -n                      Print only entries with status new"
    echo "      -i                      Print only entries with status incomplete"
    echo "      -c                      Print only entries with status complete"
    echo "      -f                      Print only flagged entries"
    echo "  m, mail [recp-list]         Email list entries"
    echo "    Options:"
    echo "      -n                      Email only entries with status new"
    echo "      -i                      Email only entries with status incomplete"
    echo "      -c                      Email only entries with status complete"
    echo "      -f                      Email only flagged entries"
    echo "  l, lists                    Show which lists are available"
    echo "  dl, deletelist <list>       Delete list"
    echo "  sl, showlists               Show entries in all lists"
    echo "    Options:"
    echo "      -n                      Show only entries with status new"
    echo "      -i                      Show only entries with status incomplete"
    echo "      -c                      Show only entries with status complete"
    echo "      -f                      Show only flagged entries"
    echo "  sel, searchlists <phrase>   Search specified phrase in all lists"
    echo "  pl, purgelists              Remove all completed entries in all lists"
    echo "  prl, printlists             Send entries in all lists to printer "
    echo "    Options:"
    echo "      -n                      Print only entries with status new"
    echo "      -i                      Print only entries with status incomplete"
    echo "      -c                      Print only entries with status complete"
    echo "      -f                      Print only flagged entries"
    echo "  ml, maillists [recp-list]   Email entries in all lists"
    echo "    Options:"
    echo "      -n                      Email only entries with status new"
    echo "      -i                      Email only entries with status incomplete"
    echo "      -c                      Email only entries with status complete"
    echo "      -f                      Email only flagged entries"
    echo "  v, version                  Show version information"
    exit 0
}

#---------------------------------------------------------------------
# SHOW_INFO_MESSAGE
#---------------------------------------------------------------------

function show_info_message {
    echo "Usage: $SCRIPTNAME [options] <command> [args]"
    echo ""
    echo "The most commonly used $SCRIPTNAME commands are:"
    echo "  h, help                   Print extended help message"
    echo "  i, info                   Print this message"
    echo "  s, show                   Show entries in list"
    echo "  a, add                    Add new entry"
    echo "  im, import                Import a file of new entries (one entry per line)"    
    echo "  d, delete                 Delete entry"
    echo "  st, status                Change status of entry"
    echo "  f, flag                   Toggle important flag"
    echo "  e, edit                   Edit entry in list"
    echo "  se, search                Perform text search on entries"
    echo "  p, purge                  Remove all completed entries"
    echo "  pr, print                 Send list entries to printer"
    echo "  m, mail                   Email list entries"    
    echo "  l, lists                  Show which lists are available"
    echo "  dl, deletelist            Delete list"
    echo "  sl, showlists             Show entries in all lists"
    echo "  sel, searchlists          Search phrase in all lists"
    echo "  pl, purgelists            Remove all completed entries in all lists"
    echo "  prl, printlists           Send entries in all lists to printer "
    echo "  ml, maillists             Email entries in all lists"    
    echo "  v, version                Show version information"
    echo ""
    echo "See '$SCRIPTNAME help' for more information."
    exit 0
}

#---------------------------------------------------------------------
# SHOW_VERSION
#---------------------------------------------------------------------

function show_version {
    echo "$SCRIPTNAME: version $GSDVERSION"
    exit 0
}

#---------------------------------------------------------------------
# SHOW_ERROR_MESSAGE
#---------------------------------------------------------------------

function show_error_message {
    echo "$SCRIPTNAME: $1"
    exit -1
}

#---------------------------------------------------------------------
# SHOW_ENTRY_DIVIDER
#---------------------------------------------------------------------

function show_entry_divider {
    # echo "======================================================================"
    # echo "//////////////////////////////////////////////////////////////////////"
    echo "----------------------------------------------------------------------"
    # echo "######################################################################"
    # echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
    # echo "**********************************************************************"
    # echo "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    # echo "<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>"
    # echo " "
}

#-------------------------------------------------------------------
# SHOW_WORKING_LIST
#--------------------------------------------------------------------

function show_working_list {

    _list=$(basename "$GSDFILE")
    _list=${_list%.*}

    echo -e "LIST: ${COLOR_LIST}$_list${COLOR_END}"

    return 0

}

#---------------------------------------------------------------------
# SHOW_ENTRY
#---------------------------------------------------------------------

function show_entry {

    declare -i _ltype

    local _ltype=$1
    local _line="$2"

    local _tag=$(show_entry_tag "$_line")
    local _status=$(show_entry_status "$_line")
    local _flag=$(show_entry_flag "$_line")
    local _statement=$(show_entry_statement "$_line")

    # Pad the entry tag
    # Currently formatted to keep tags 1-999 aligned
    _tag=$(printf '%3i' "$_tag")

    show_entry_divider

    check_important_flag "$_line"
    if [ $? -eq 1 ]; then
        _flag_print="$COLOR_FLAG$_flag$COLOR_END "
    else
        _flag_print=""
    fi

    case $_ltype in

        1|19)
            echo -e "$_tag $COLOR_NEW$_status$COLOR_END : $_flag_print$_statement"
            ;;
        2|29)
            echo -e "$_tag $COLOR_INCOMPLETE$_status$COLOR_END : $_flag_print$_statement"
            ;;
        3|39)
            echo -e "$_tag $COLOR_COMPLETE$_status$COLOR_END : $_flag_print$_statement"
            ;;
        *)
            show_error_message "incorrect entry type"
            ;;
    esac

    return 0
}

######################################################################
# STANDARD FUNCTIONS
######################################################################

#---------------------------------------------------------------------
# LOWERCASE
#---------------------------------------------------------------------

function lowercase {
    # Converts all chracters in string to lower case
    local _string="$1"

    _string=$(echo $_string|tr [:upper:] [:lower:])
    echo $_string

    return 0

}

#--------------------------------------------------------------------
# SED_WRITE_LINE (GNU STYLE)
#--------------------------------------------------------------------
# This function is called using the global variable SED_WRITE_LINE
function sed_write_line {

    local _linenumber="$1"
    local _line="$2"
    local _file="$3"

    sed -i.tmp "$_linenumber c$_line" $_file

    [ $? -ne 0 ] && print_error_message "unable to write line"

    return 0

}

#--------------------------------------------------------------------
# SED_WRITE_LINE_BSD (BSD STYLE)
#--------------------------------------------------------------------
# This function is called using the global variable SED_WRITE_LINE
function sed_write_line_bsd {

    local _linenumber="$1"
    local _line="$2"
    local _file="$3"

    sed -i.tmp "$_linenumber c\\
    $_line\\
    " $_file

    [ $? -ne 0 ] && print_error_message "unable to write line"

    return 0

}

######################################################################
# LINE EXTRACTION FUNCTIONS
######################################################################

#-------------------------------------------------------------------
# SHOW_ENTRY_TAG
#--------------------------------------------------------------------

function show_entry_tag {

    local _line="$1"
    local _tag

    _tag="`echo $_line | cut -d: -f 1`"
    echo $_tag

    return 0
}

#-------------------------------------------------------------------
# SHOW_ENTRY_STATUS
#--------------------------------------------------------------------
# This function shows the status of a valid entry
function show_entry_status {
    local _line="$1"
    local _status

    _status="`echo $_line | cut -d: -f 2`"
    echo $_status

    return 0
}

#-------------------------------------------------------------------
# SHOW_ENTRY_FLAG
#--------------------------------------------------------------------
# This function shows the flag from a valid entry
function show_entry_flag {

    local _line="$1"
    local _status

    _status="`echo $_line | cut -d: -f 3`"
    echo $_status

    return 0
}


#--------------------------------------------------------------------
# SHOW_ENTRY_STATEMENT
#--------------------------------------------------------------------
# This function shows the statement of a valid entry
function show_entry_statement {

    # This function assumes that a valid line is provided
    local  _line="$1"
    local _pre_statement
    local _statement

    # Get the tag, status, and flag in one swipe
    _pre_statement="`echo $_line | cut -f'1-3' -d:`"

    # Trim leading part of string instead of using delimiter so that
    # the statement can contain the delimiter; unfortunately this is
    # slower but it is more robust
    _statement=${_line#"$_pre_statement:"*}
    echo $_statement

    return 0

}

######################################################################
# LINE CHECKING FUNCTIONS
######################################################################

#---------------------------------------------------------------------
# CHECK_IMPORTANT_FLAG
# --------------------------------------------------------------------
# Checks whether or not the important flag is set (currently this is
# the only flag
function check_important_flag {

    # For safety only valid statements should call this
    local _line="$1"
    local _flag

    _flag=$(show_entry_flag "$_line")

    # First see if the statement is marked as important
    if [[ "$_flag" == "(*)" ]]; then
        return 1
    else
        return 0
    fi
}

#-------------------------------------------------------------------
# CHECK_LINE_TYPE
#--------------------------------------------------------------------
# Checks line type: blank, comment, or status+flag
function check_line_type {

    # This function uses special formatting rules of GSD
    local _line="$1"
    local _status
    local _statement
    local _firstchar
    local _linelength=${#_line}

    declare -i _type
    local _type

    declare -i _flagged
    local _flagged

#    echo $_line

    _firstchar=${_line::1}

    if [ $_linelength -eq 0 ]; then
        # Treating as blank line
        return 0
    elif [[ "$_firstchar" == "#" ]]; then
        # Treating as a comment
        return 11
    fi

    # Considerd valid entry line
    _status=$(show_entry_status "$_line")
    _statement=$(show_entry_statement "$_line")

    # Check the status
    case $_status in
        "(N)")
            _type=1
            ;;
        "(I)")
            _type=2
            ;;
        "(C)")
            _type=3
            ;;
        *)
            show_error_message "line in list not formatted correctly"
    esac

    check_important_flag "$_line"
    _flagged=$?

    case $_flagged in
        0)
            return $_type
            ;;
        1)
            return $((10*_type+9))
            ;;
    esac

}

#-------------------------------------------------------------------
# GET_ENTRY_LINE_NUMBER
#--------------------------------------------------------------------
# Retrieves the line number that a valid entry exists
function get_entry_line_number {

    # This function will exit on error

    local _tag="$1"
    local _n
    local _line
    local _ltype

    for _n in `grep -n "$_tag:" $GSDFILE | cut -f1 -d:`
    do

        _line=$(sed -n ${_n}p $GSDFILE)

        check_line_type "$_line"
        _ltype=$?

        # Make sure its a valid entry
        if [ $_ltype -ne 0 -a $_ltype -ne 11 ]; then
            _tagtest=$(show_entry_tag "$_line")
            [[ "$_tag" == "$_tagtest" ]] && return $_n
        fi

    done

    # Should have returned by now
    show_error_message "specified tag not found"

}

#-------------------------------------------------------------------
# SHOW_LAST_ENTRY_TAG
#-------------------------------------------------------------------
# Shows the tag of the last entry in a list
function show_last_entry_tag {

    local _gsdfile_rev="${GSDFILE}.tmp"
    local _ltype
    local _line

    rm -f "$_gsdfile_rev" || show_error_message "unable to cleanup: check $GSDDIR permissions"

    # Create reversed list
    cat "${GSDFILE}" | sort -nr >> "$_gsdfile_rev"

    while read _line; do

        check_line_type "$_line"
        _ltype=$?

        case $_ltype in
            0|11) # Blank line or comment
                ;;
            [1-3]|19|29|39)
                # Return upon first valid entry
                echo $(show_entry_tag "$_line")
                rm -f "$_gsdfile_rev" && return 0
                show_error_message "unable to cleanup: check $GSDDIR permissions"
                ;;
            *)
                show_error_message "error on read"
                ;;
        esac

    done < "$_gsdfile_rev"

    # If nothing is found
    echo 0

    rm -f "$_gsdfile_rev" && return 0
    show_error_message "unable to clean up: check $GSDDIR permissions"

}

######################################################################
# ACTION FUNCTIONS
######################################################################
#
# Each of these functions are required to be error checking and must
# exit the program using show_error_message if an error is
# encountered
#

#-------------------------------------------------------------------
# SHOW_ENTRIES
#--------------------------------------------------------------------

function show_entries {

    local _stype=$1
    local _ltype
    local _flagged
    local _line
    local _list
    local _entry

    declare -i _one_shown
    local _one_shown=0

    while read _line; do

        check_line_type "$_line"
        _ltype=$?

        # Ignore blank or commented lines
        if [ $_ltype -ne 0 -a $_ltype -ne 11 ]; then

            case $_stype in
                0)
                    # Print all valid entries
                    _entry=$(show_entry $_ltype "$_line")
                    ;;
                1)
                    [ $_ltype -eq 1 -o $_ltype -eq 19 ] && _entry=$(show_entry $_ltype "$_line")
                    ;;
                2)
                    [ $_ltype -eq 2 -o $_ltype -eq 29 ] && _entry=$(show_entry $_ltype "$_line")
                    ;;
                3)
                    [ $_ltype -eq 3 -o $_ltype -eq 39 ] && _entry=$(show_entry $_ltype "$_line")
                    ;;
                9)
                    [ $_ltype -eq 19 -o $_ltype -eq 29 -o $_ltype -eq 39 ] && _entry=$(show_entry $_ltype "$_line")
                    ;;
            esac

        fi

        # Check if entry is empty (it may be depending on _ltype)
        if [[ ! -z "$_entry" ]]; then

            if [ $_one_shown -eq 0 ]; then
                _one_shown=1
                show_working_list
            fi

            echo "$_entry"
            unset _entry

        fi

    done < $GSDFILE

    # Print entry divider
    [ $_one_shown -eq 1 ] && show_entry_divider

}


#-------------------------------------------------------------------
# ASCII_FORMAT_ENTRIES
#--------------------------------------------------------------------

function ascii_format_entries {

    local _stype=$1
    local _output=$2

    # Colored printing not supported; Unset color variables as a
    # workaround
    unset COLOR_NEW
    unset COLOR_INCOMPLETE
    unset COLOR_COMPLETE
    unset COLOR_FLAG
    unset COLOR_LIST
    unset COLOR_END

    # Send to printer; requires $PRINTER to be set
    show_entries $_stype > $_output

    [ $? -ne 0 ] && show_error_message "unable to format entries"

    return 0

}


#-------------------------------------------------------------------
# PRINT_ENTRIES
#--------------------------------------------------------------------

function print_entries {
    local _stype=$1
    
    ascii_format_entries $_stype $GSDDIR/.entries
    
    cat $GSDDIR/.entries | lpr -p    
    local rc=$?
    rm -f $GSDDIR/.entries
    
    [ $rc -ne 0 ] && show_error_message "unable to print"

    return 0

}

#-------------------------------------------------------------------
# MAIL_ENTRIES
#--------------------------------------------------------------------

function mail_entries {

    local _stype=$1
    
    ascii_format_entries $_stype $GSDDIR/.entries

    mail -s "gsd: $(date)" "${MAIL_RECIPIENT}" < $GSDDIR/.entries
    local rc=$?
    rm -f $GSDDIR/.entries
    
    [ $rc -ne 0 ] && show_error_message "unable to mail to ${MAIL_RECIPIENT}"

    return 0

}

#-------------------------------------------------------------------
# MODIFY_ENTRY_STATUS
#--------------------------------------------------------------------

function modify_entry_status {

    local _status="$1"
    local _tag="$2"

    local _statement
    local _line
    local _linenumber

    #get_entry_line_number "$_tag"
    get_entry_line_number "$_tag"
    _linenumber=$?

    _line=$(sed -n ${_linenumber}p $GSDFILE)

    _flag=$(show_entry_flag "$_line")
    # Extract the statement
    _statement=$(show_entry_statement "$_line")

    # Update the entry in the gsd file
    #sed -i.tmp "$_linenumber c$_tag:$_status:$_flag:$_statement" $GSDFILE
    $SED_WRITE_LINE "$_linenumber" "$_tag:$_status:$_flag:$_statement" "$GSDFILE"

    if [ $? -ne 0 ]; then
        cp $GSDFILE.tmp $GSDFILE
        show_error_message "could not update entry status"
    else
        rm -f $GSDFILE.tmp
    fi

    return 0

}

#-------------------------------------------------------------------
# MODIFY_ENTRY_STATMENT
#--------------------------------------------------------------------

function modify_entry_statement {

    local _tag="$1"

    local _status
    local _linenumber

    #get_entry_line_number "$_tag"
    get_entry_line_number "$_tag"
    _linenumber=$?

    # Extract the line
    _line=$(sed -n ${_linenumber}p $GSDFILE)

    # Extract the status
    _status=$(show_entry_status "$_line")
    # Extract flag
    _flag=$(show_entry_flag "$_line")
    # Create tmp file with old statement and open
    show_entry_statement "$_line" > $GSDFILE-entry${_tag}.tmp

    $EDITOR $GSDFILE-entry${_tag}.tmp
    _statement=$(cat $GSDFILE-entry${_tag}.tmp)
    rm -f $GSDFILE-entry${_tag}.tmp

    # Generate entry
    _line="$_tag:$_status:$_flag:$_statement"

    # Update the entry in the gsd file
    #sed -i.tmp "$_linenumber c$_line" $GSDFILE
    $SED_WRITE_LINE "$_linenumber" "$_line" "$GSDFILE"

    if [ $? -ne 0 ]; then
        cp $GSDFILE.tmp $GSDFILE
        show_error_message "could not modify entry statement"
    else
        rm -f $GSDFILE.tmp
    fi

    return 0

}

#-------------------------------------------------------------------
# ADD_ENTRY
#--------------------------------------------------------------------

function add_entry {

    local _statement="$1"
    local _tag

    _tag=$(show_last_entry_tag)
    _tag=$((_tag+1))
    echo "$_tag:(N)::$_statement" >> $GSDFILE

    if [ $? -eq 0 ]; then
	echo "Added new entry at tag $_tag"
        return 0
    else
        show_error_message "unable to add new entry"
    fi

}

#-------------------------------------------------------------------
# ADD_ENTRY
#--------------------------------------------------------------------

function import_entries {

    local _file="$1"

    while read line
    do
	add_entry "$line"
    done<$_file

}
#-------------------------------------------------------------------
# DELETE_ENTRY
#--------------------------------------------------------------------

function delete_entry {

    local _tag="$1"
    local _ltype
    local _testtag

    local _status
    local _linenumber

    #get_entry_line_number "$_tag"
    get_entry_line_number "$_tag"
    _linenumber=$?

    # Delete the entry in the gsd file
    sed -i.tmp "$_linenumber d" $GSDFILE

    if [ $? -ne 0 ]; then
        cp $GSDFILE.tmp $GSDFILE
        show_error_message "could not delete entry"
    else
        rm -f $GSDFILE.tmp
    fi

    return 0

}

#-------------------------------------------------------------------
# SEARCH_ENTRIES
#--------------------------------------------------------------------

function search_entries {

    local _phrase="$1"
    local _n
    local _line
    local _ltype
    local _flagged

    declare -i _found_one
    local _found_one=0

    for _n in `grep -i -n "$_phrase" $GSDFILE | cut -f1 -d:`
    do

        _line=$(sed -n ${_n}p $GSDFILE)

        check_line_type "$_line"
        _ltype=$?

        if [ $_ltype -ne 0 -a $_ltype -ne 11 ]; then

            # Make sure what we found is in the statement
            _statement=$(show_entry_statement "$_line")
            # Make statement all lower case
            _statement=$(lowercase "$_statement")
            _phrase=$(lowercase "$_phrase")

            if [[ "$_statement" == *"$_phrase"* ]]; then

                [ $_found_one -eq 0 ] && show_working_list
                show_entry $_ltype "$_line"

                _found_one=1

            fi

        fi

    done

    [ $_found_one -eq 1 ] && show_entry_divider

    return 0

}

#-------------------------------------------------------------------
# PURGE_COMPLETED_ENTRIES
#--------------------------------------------------------------------

function purge_completed_entries {

    local _ltype
    local _line

    # Get all suspicious lines; notice the sort -nr at the end - we
    # must delete them in reverse order otherwise we'll delete the
    # wrong lines since things are shifted upwards after a delete
    for _linenumber in `grep -n ":(C):" $GSDFILE | cut -f1 -d: | sort -nr`
    do
        # Read the line
        _line=$(sed -n ${_linenumber}p $GSDFILE)

        check_line_type "$_line"
        _ltype=$?

        # Make sure its a valid entry and has status complete
        if [ $_ltype -eq 3 -o $_ltype -eq 39 ]; then

            # Delete the entry in the gsd file
            sed -i.tmp "$_linenumber d" $GSDFILE

            if [ $? -ne 0 ]; then
                cp $GSDFILE.tmp $GSDFILE
                show_error_message "could not delete entry"
            else
                rm -f $GSDFILE.tmp
            fi

        fi

    done

    return 0

}

#-------------------------------------------------------------------
# REORDER_ENTRY_TAGS
#--------------------------------------------------------------------

function reorder_entry_tags {

    # This function reorders ("sequentializes") them and has the nice
    # side-effect of removing blank lines

    local _flag
    local _status
    local _statement
    local _ltype
    local _line

    declare -i _tag
    local _tag

    rm -f $GSDFILE.tmp
    touch $GSDFILE.tmp

    [ $? -ne 0 ] && show_error_message "cannot create temporary file"

    _tag=0
    while read _line; do

        check_line_type "$_line"
        _ltype=$?

        if [ $_ltype -eq 11 ]; then
            # Put the line back if it is a comment
            echo "$_line" >> $GSDFILE.tmp
        elif [ $_ltype -ne 0 ]; then

            # Update the tag number
            _tag=$((_tag+1))
            _status=$(show_entry_status "$_line")
            _flag=$(show_entry_flag "$_line")
            _statement=$(show_entry_statement "$_line")
            echo "$_tag:$_status:$_flag:$_statement" >> $GSDFILE.tmp

        fi

    done < $GSDFILE

    cp $GSDFILE.tmp $GSDFILE
    rm -f $GSDFILE.tmp

    return 0

}

#-------------------------------------------------------------------                                                                                                        # BUMP_ENTRY
#-------------------------------------------------------------------                                                                                                        

function bump_entry {

# This function repositions ("bumps") the entry at tag a to
# new position at tag b.

local _a   # tag to move
local _b   # tag to move to
local _fin # final tag in list

rm -f $GSDFILE.tmp
touch $GSDFILE.tmp
[ $? -ne 0 ] && show_error_message "cannot create temporary file"

rm -f $GSDFILE.bak
cp $GSDFILE $GSDFILE.bak

_a=$1
_b=$2
_fin=$(tail -n 1 $GSDFILE.bak | grep -o -E '[0-9]+')
sed -i.tmp "$_a d" $GSDFILE.bak
if [ "$_a" != "$_fin" ] && [ "$_b" != "1" ]; then
  # grab first chunk of entries
  awk -v var=$_b 'NR==1,NR==((var-1))' $GSDFILE.bak >> $GSDFILE.tmp
fi
# grab entry to move
awk -v var=$_a 'NR==var' $GSDFILE >> $GSDFILE.tmp
# grab last chunk of entries
awk -v vara=$_b -v varb=$_fin 'NR==((vara)),NR==varb' $GSDFILE.bak >> $GSDFILE.tmp

# clean up
cp $GSDFILE.tmp $GSDFILE
rm -f $GSDFILE.tmp
rm -f $GSDFILE.bak

# re-sequence the tags since they have been shuffled
reorder_entry_tags

return 0

}

#-------------------------------------------------------------------
# TOGGLE_IMPORTANT_FLAG
#--------------------------------------------------------------------

function toggle_important_flag {

    local _tag_spec="$1"
    (( $# == 2 )) && local _state="$2" # State which only to toggle ("on" or "off")

    local _state_crit # Change criterion

    _state_crit=0
    if [ ! -z $_state ]; then
	case $_state in
	    "off") 
		_state_crit=11 # Must have current state on
		;;
	    "on")
		_state_crit=10 # Must have current state off
		;;
	    *)
		show_error_message "toogle state not specified correctly"
		;;
	esac
    fi

    local _status
    local _flag
    local _statement

    local _line
    local _linenumber
    local _tag_sets
    local _tag_range
    local _tag_set

    IFS=',' read -ra _tag_sets <<< "$_tag_spec"
    for _tag_set in ${_tag_sets[@]}
    do
	local -i _tag_start;
	local -i _tag_end;
	local -i _tag
	
	if [[ $_tag_set == *"-"* ]]; then
	    IFS='-' read -ra _tag_range <<< "$_tag_set"

	    if (( ${#_tag_range[@]} != 2 )); then
		show_error_message "tag range $_tag_set not specified correctly"
	    fi
	    _tag_start=${_tag_range[0]}
	    _tag_end=${_tag_range[1]}
	else
	    _tag_start=$_tag_set
	    _tag_end=$_tag_start
	fi
	
	if (( _tag_end < _tag_start )); then
	    show_error_message "tag range $_tag_set not specified correctly"
	fi
	
	for (( _tag = $_tag_start; _tag <= $_tag_end; ++_tag ))
	do
	    get_entry_line_number "$_tag"
	    _linenumber=$?

	    _line=$(sed -n ${_linenumber}p $GSDFILE)

	    # Extract the status
	    _status=$(show_entry_status "$_line")
	    _statement=$(show_entry_statement "$_line")

	    # First see if the statement is marked as important
	    check_important_flag "$_line"

	    if (( $? == 1 && ( $_state_crit == 0 || $_state_crit == 11 ) )); then
		_flag=""
	    elif (( $_state_crit == 0 || $_state_crit == 10 )); then
		_flag="(*)"
		# Add important tag
	    else
		# Not changing the entry
		return 0 
	    fi

	    # Reconstruct the line
	    _line="$_tag:$_status:$_flag:$_statement"

	    # Update the entry in the gsd file
	    #sed -i.tmp "$_linenumber c$_line" $GSDFILE
	    $SED_WRITE_LINE "$_linenumber" "$_line" "$GSDFILE"

	    if [ $? -ne 0 ]; then
		cp $GSDFILE.tmp $GSDFILE
		show_error_message "could not toggle flag"
	    else
		rm -f $GSDFILE.tmp
	    fi
	done
    done
    
    return 0

}

#####################################################################
# LISTS FUNCTIONS
#####################################################################

#-------------------------------------------------------------------
# SHOW_AVAILABLE_LISTS
#--------------------------------------------------------------------

function show_available_lists {

    local _list

    for _list in `ls $GSDDIR/*.lst 2> /dev/null`
    do
        _list=`basename "$_list"`
        echo ${_list%.*}
    done

    return 0

}

#-------------------------------------------------------------------
# DELETE_LIST
#--------------------------------------------------------------------

function delete_list {

    local _gsdfile="${GSDDIR}/$1.lst"    

    if [ ! -f "$_gsdfile" ]; then
        show_error_message "specified list does not exisit"
    else
        rm $_gsdfile
    fi

    return 0

}

#---------------------------------------------------------------------
# SEARCH_ENTRIES_ALL_LISTS
#---------------------------------------------------------------------

function search_entries_all_lists {

    local _phrase="$1"
    local _list

    # Get all available lists
    for _list in `show_available_lists`
    do

        GSDFILE="${GSDDIR}/${_list}.lst"
        search_entries "$_phrase"

    done

    return 0

}

#---------------------------------------------------------------------
# SHOW_ENTRIES_ALL_LISTS
#---------------------------------------------------------------------

function show_entries_all_lists {

    local _stype=$1
    local _list

    # Get all available lists
    for _list in `show_available_lists`
    do
        GSDFILE="${GSDDIR}/${_list}.lst"
        show_entries $_stype

    done

    return 0

}

#-------------------------------------------------------------------
# PURGE_COMPLETED_ENTRIES_ALL_LISTS
#--------------------------------------------------------------------

function purge_completed_entries_all_lists {

    local _list

    # Get all available lists
    for _list in `show_available_lists`
    do
        GSDFILE="${GSDDIR}/${_list}.lst"
        purge_completed_entries

    done

    return 0

}

#-------------------------------------------------------------------
# ASCII_FORMAT_ENTRIES
#--------------------------------------------------------------------

function ascii_format_entries_all_lists {

    local _stype=$1
    local _output=$2

    # Colored printing not supported; Unset color variables as a
    # workaround
    unset COLOR_NEW
    unset COLOR_INCOMPLETE
    unset COLOR_COMPLETE
    unset COLOR_FLAG
    unset COLOR_LIST
    unset COLOR_END

    # Send to printer; requires $PRINTER to be set
    show_entries_all_lists $_stype > $_output

    [ $? -ne 0 ] && show_error_message "unable to format entries"

    return 0

}

#---------------------------------------------------------------------
# PRINT_ENTRIES_ALL_LISTS
#---------------------------------------------------------------------

function print_entries_all_lists {
    local _stype=$1
    
    ascii_format_entries_all_lists $_stype $GSDDIR/.entries
    
    cat $GSDDIR/.entries | lpr -p    
    local rc=$?
    rm -f $GSDDIR/.entries
    
    [ $rc -ne 0 ] && show_error_message "unable to print lists"

    return 0

}

#-------------------------------------------------------------------
# MAIL_ENTRIES_ALL_LISTS
#--------------------------------------------------------------------

function mail_entries_all_lists {

    local _stype=$1
    
    ascii_format_entries_all_lists $_stype $GSDDIR/.entries
    
    mail -s "gsd: $(date)" "${MAIL_RECIPIENT}" < $GSDDIR/.entries
    local rc=$?
    rm -f $GSDDIR/.entries
    
    [ $rc -ne 0 ] && show_error_message "unable to mail lists to ${MAIL_RECIPIENT}"

    return 0

}

function set_stype {
    case $1 in
	"-n")
	    STYPE=1
	    ;;
	"-i")
	    STYPE=2
	    ;;
	"-c")
	    STYPE=3
	    ;;
	"-f")
	    STYPE=9
	    ;;
	"-h")
	    show_usage_message
	    ;;
	*)
	    show_error_message "incorrect option"
	    ;;
    esac
}

#####################################################################
# MAIN
#####################################################################

# Process options
while [[ $1 == "-"* ]]
do
    (( $# < 2 )) && show_error_message "option $1 requires an argument"
    
    case $1 in
	"-c")
	    GSDCONFIG="$2"
	    [ ! -f $GSDCONFIG ] && show_error_message "unable to find $GSDCONFIG"
	    shift 2
	    ;;
	"-d")
	    GSDDIR="$2"
	    shift 2
	    ;;
	"-l")
	    GSDLIST="$2"
	    shift 2
	    ;;
	*)
            show_error_message "incorrect option"
            ;;
    esac
done

GSDCONFIG=${GSDCONFIG:-"$GSDDIR/config"}
GSDFILE="$GSDDIR/$GSDLIST.lst"

# First check that the GSD file exists and is readable
if [ ! -d $GSDDIR ]; then
    mkdir $GSDDIR
    [ $? -ne 0 ] && show_error_message "unable to create $GSDDIR"
fi

if [ -f $GSDCONFIG ]; then
    . $GSDCONFIG
fi

DARK_BACKGROUND=${DARK_BACKGROUND:-yes}
MAIL_RECIPIENT=${MAIL_RECIPIENT:-"${USER}@localhost"}
EDITOR=${EDITOR:-vim}

# Specify colors for new, incomplete, completed and flagged Besure to
# use the ANSI code \033 and not the escape character \e to support
# both Linux and Mac
if [[ "$DARK_BACKGROUND" == "yes" ]]; then
    COLOR_NEW="\033[${BLUE}m"
    COLOR_INCOMPLETE="\033[${YELLOW}m"
    COLOR_COMPLETE="\033[${GREEN}m"
else
    COLOR_NEW="\033[${BLUE}m"
    COLOR_INCOMPLETE="\033[${CYAN}m"
    COLOR_COMPLETE="\033[${MAGENTA}m"
fi

declare -i STYPE=0
declare -i ETYPE=0

if (( $# >= 1 )); then
    ACTION="$1"
    shift
else
    # Show info message if no command is specified
    ACTION="info"
fi

# Check for immediate action items
case $ACTION in

    "help" | "h")
        show_usage_message
	exit 0
        ;;
    "info" | "i")
        show_info_message
	exit 0
        ;;
    "version" | "v")
        show_version
	exit 0	
        ;;
esac

#
# Perform pre-action item tasks
#
# Check if list exist; if not create it
if [ ! -f $GSDFILE ]; then
    touch "$GSDFILE"
    [ $? -ne 0 ] && show_error_message "unable to create $GSDFILE"
fi

case $ACTION in

    "mail" | "m" | "maillists" | "ml" )
        if (( $# > 2 )); then
	    show_error_message "$ACTION only requires at most two options"
        fi

	if (( $# >= 1 )) && [[ $1 == "-"* ]];  then
	    set_stype $1
	    shift
	fi
	
	if (( $# > 0 )); then
	    MAIL_RECIPIENT="$1"
	    shift
	fi
	
	case $ACTION in
	    "mail" | "m") 
		mail_entries $STYPE
		;;
	    "maillists" | "ml")
		mail_entries_all_lists $STYPE
		;;
	    *)
		show_error_message "fatal"
	esac
	;;
	
    "show" | "s" | "showlists" | "sl" | "print" | "pr" | "printlists" | "prl" )

	if (( $# > 0 )); then

            if (( $# > 1 )); then
		show_error_message "$ACTION only requires one option"
            fi

	    set_stype $1
	    shift
	fi

	case $ACTION in
	    "show" | "s") 
		ENTRIES="$(show_entries ${STYPE})"
		[[ ! -z $ENTRIES ]] && echo "$ENTRIES"
		;;
	    "showlists" | "sl")
		ENTRIES="$(show_entries_all_lists ${STYPE})"
		[[ ! -z $ENTRIES ]] && echo "$ENTRIES"
		;;
	    "print" | "pr") 
		print_entries $STYPE
		;;
	    "printlists" | "prl")
		print_entries_all_lists $STYPE
		;;
	    *)
		show_error_message "fatal"
	esac
	;;

    "add" | "a")
	
	(( $# != 1 )) && show_error_message "$ACTION requires <tag>"
        # Append new entry
	add_entry "$1"
	;;

    "import" | "im")
	
	(( $# != 1 )) && show_error_message "$ACTION requires <file>"
        # Append new entry
	import_entries "$1"
	;;
    
    "delete" | "d")

	(( $# != 1 )) && show_error_message "$ACTION requires <tag>"
	delete_entry "$1"
	;;

    "status" | "st")
	(( $# != 2 )) && show_error_message "$ACTION requires <status> <tag>"

	STATUS_SYMB=$1
	TAG=$2
    
	case $STATUS_SYMB in
            "n"|"N")
		STATUS="(N)"
		;;
            "i"|"I")
		STATUS="(I)"
		;;
            "c"|"C")
		STATUS="(C)"
		;;
            *)
		show_error_message "status not specified correctly"
		;;
	esac

        # Modify entry
	modify_entry_status "$STATUS" "$TAG"
	
        # Toggle completed items off
	[[ $STATUS == "(C)" ]] && toggle_important_flag "$TAG" "off"
	;;

    "flag" | "f")

	(( $# != 1 )) && show_error_message "$ACTION requires <tag-spec>"   
	toggle_important_flag "$1"
	
	;;

    "edit" | "e")
     
        # Edit entry
	(( $# == 0 )) && show_error_message "$ACTION requires at least one option"

	case $1 in

            "-m")

		(( $# != 2 )) && show_error_message "$ACTION $1 requires <tag>"
		TAG=$2
		modify_entry_statement "$TAG"
		;;

            "-r")

		reorder_entry_tags
		;;

            "-h")

		show_usage_message
		;;

            *)

		show_error_message "not a valid edit option"
		;;

	esac
	;;

    "search" | "se")

	(( $# != 1 )) && show_error_message "$ACTION requires search phrase"
	ENTRIES="$(search_entries "$1")"
	[[ ! -z $ENTRIES ]] && echo "$ENTRIES"
	;;

    "bump" | "b")
	
	(( $# != 2 )) && show_error_message "$ACTION requires two arguments"
        # Bump entry at tag a to tag b
	bump_entry "$1" "$2"
	;;
    
    "purge" | "p")
	
	(( $# != 0 )) && show_error_message "$ACTION takes no arguments"
        # Purge all entries with status complete
	purge_completed_entries
	;;

    "lists" | "l")

        # Show available lists
	(( $# != 0 )) && show_error_message "$ACTION takes no arguments"
	ENTRIES="$(show_available_lists)"
	[[ ! -z $ENTRIES ]] && echo "$ENTRIES"
	;;
    
    "deletelist" | "dl")

        # Delete specified list
	(( $# != 1 )) && show_error_message "$ACTION requires <list>"
	delete_list "$1"
	;;

    "searchlists" | "sel")
	
	(( $# != 1 )) && show_error_message "$ACTION requires search phrase"
	ENTRIES="$(search_entries_all_lists "$1")"
	[[ ! -z $ENTRIES ]] && echo "$ENTRIES"
	;;
    
    "purgelists" | "pl")
	
	(( $# != 0 )) && show_error_message "$ACTION takes no arguments"
        # Purge all entries with status complete
	purge_completed_entries_all_lists
	;;

    *)
	show_error_message "no action specified"
	;;
    
        
esac
    
exit 0

